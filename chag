#!/usr/bin/env bash
#
# Parses changelog entries / create annotated git tags from a changelog entry.
#
# Author:  Michael Dowling <https://github.com/mtdowling>
# License: MIT <https://github.com/mtdowling/chag/blob/master/LICENSE>
# URL:     https://github.com/mtdowling/chag

set -e

# Clear out the variables used in the script
unset COMMAND FILENAME TAG SIGN FORCE ADDV

# Tag heading regular expressions
HEADING_START='[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+'
HEADING_END='\([[:digit:]]{4}\-[[:digit:]]{2}\-[[:digit:]]{2}\)$'

version() {
  echo "chag 0.1.0"
}

usage() {
  version
  cat <<EOT
Usage: chag [OPTIONS] COMMAND [ARGS]...

Options:
  --help     Displays this message.
  --version  Displays the version number.

Commands:
  parse      Get the contents of a specific changelog entry.
  tag        Create an annotated git tag based on a changelog entry.
  latest     Get the latest tag in a changelog.
  list       List all tags in a changelog file.

EOT
}

parse_usage() {
  cat <<EOT
Usage: chag parse [OPTIONS] FILENAME TAG

Options:
  --debug    Output debug information while executing.
  --help     Displays this message.

Arguments:
  FILENAME   Path to the changelog file to parse.
  TAG        The tag to parse from the changelog. Pass the string "latest"
             to parse the latest changelog entry.

Description:
  Parses a changelog entry from a changelog file. A changelog
  file consists of various release entries, each designated by a line
  that matches the following pattern: '\d+\.\d+\.\d+ \(\d{4}\-\d{2}\d{2}\)'
  After each release entry heading, are two lines of text that are
  disregarded, followed by n number of lines of the changelog entry
  content. An entry is parsed until the next heading or EOF.

Output:
  Writes the contents of the matching changelog entry to STDOUT.

Examples:

  ./chag /path/to/CHANGELOG.md 2.0.0

EOT
}

tag_usage() {
  cat <<EOT
Usage: chag tag [OPTIONS] FILENAME TAG

Options:
  --add-v     Pass to prepend a "v" to the git tag (e.g., "v2.0.1")
  --sign|-s   Make a GPG-signed tag, using the default git e-mail address's
              key.
  --force|-f  Delete an existing tag if present.
  --debug     Output debug information while executing.
  --help      Displays this message.

Arguments:
  FILENAME    Path to the changelog to parse.
  TAG         Tag to parse from the changelog file. Pass the string "latest"
              to parse and tag the latest changelog entry.

Description:
  Parses a changelog entry for the given tag and creates an annotated git tag
  based on the changelog entry.

Examples:
  ./chag tag /path/to/CHANGELOG.md 2.0.0
  ./chag tag --debug CHANGELOG.rst 2.0.0
  ./chag tag --sign CHANGELOG.rst 2.0.0
  ./chag tag -s CHANGELOG.rst 1.0.0
  ./chag tag --force CHANGELOG.rst 2.0.0
  ./chag tag -f CHANGELOG.rst 2.0.0

EOT
}

latest_usage() {
  cat <<EOT
Usage: chag latest [OPTIONS] FILENAME

Options:
  --help    Displays this message.

Arguments:
  FILENAME  Path to the changelog to parse.

Description:
  Get the latest tag in a changelog.

Examples:
  ./chag latest /path/to/CHANGELOG.md
  Outputs: 2.0.0

EOT
}

list_usage() {
  cat <<EOT
Usage: chag list [OPTIONS] FILENAME

Options:
  --help    Displays this message.

Arguments:
  FILENAME  Path to the changelog to parse.

Description:
  Lists all of the tag numbers in a changelog file, separated by new lines.

Examples:
  ./chag list /path/to/CHANGELOG.md

EOT
}

# exits with an error message
die() {
  echo "$@" 1>&2
  exit 1
}

# Outputs debug information if DEBUG was passed
debug() {
  if [ ! -z "$DEBUG" ]; then
    printf "$@\n" >&2
  fi
}

# Extracts options and arguments, validates, and calls a subcommand
main() {
  # Show help if no options or arguments are provided
  [ $# -eq 0 ] && set -- --help

  # Showing help or the version should exit immediately
  [ "$1" == '--help' ] && usage && exit 0
  [ "$1" == '--version' ] && version && exit 0

  COMMAND="$1"
  shift

  # Call the appropriate command or display the command's help message
  case "$COMMAND" in
    parse|tag|latest|list)
      # Each command has a "command"_usage function
      if [ "$1" == "--help" ]; then
        help_cmd=$COMMAND
        help_cmd+="_usage"
        $help_cmd
        exit 0
      fi
      parse_options $@
      $COMMAND
      ;;
    *)
      die "ERROR: Unknown command '$COMMAND'." \
          "Available commands: parse|tag|latest|list"
      ;;
  esac
}

# Parses the provided options, FILENAME, and TAG
parse_options() {
  while [ $# -gt 0 ]; do
    opt="$1"
    shift
    case "$opt" in
      --debug) DEBUG=1 ;;
      --sign|-s) SIGN="--sign" ;;
      --force|-f) FORCE="--force" ;;
      --add-v) ADDV=1 ;;
      --*) die "ERROR: Unknown option '$opt'" ;;
      *) FILENAME=$opt; break ;;
    esac
  done

  if [ "$FILENAME" == "" ]; then
    die "$COMMAND requires a FILENAME argument"
  fi

  if [ ! -f "$FILENAME" ]; then
    die "File not found: $FILENAME"
  fi

  case "$COMMAND" in
    parse|tag)
      TAG="$1"
      # Handle the "latest" value
      if [ "$TAG" == "latest" ]; then
        TAG=$(latest "$FILENAME")
      elif [ -z "$TAG" ]; then
        die "$COMMAND requires a TAG argument"
      fi
      ;;
  esac
}

# Parses a changelog and displays changelog information
parse() {
  # Find the tag pattern
  local match=$(grep -n -E -e "^$TAG $HEADING_END" $FILENAME | head -n1)
  [ "$match" == "" ] && die "Tag $TAG not found in $FILENAME"

  # Parse the match: 0:0.0.0 (0000-00-00)
  local found_line=$(echo "$match" | cut -d ':' -f 1)

  # First line in the file of the changelog
  local start_line=$(($found_line + 2))
  # Find the length of the section
  local length=$(tail -n +$start_line "$FILENAME" | \
                 grep -n -E "^$HEADING_START $HEADING_END" | \
                 head -n1 | \
                 cut -d ':' -f 1)
  # Remove the extra lines
  length=$(($length - 3))

  if [ "$length" -gt 0 ]; then
    # This is NOT at the end of the file
    local headn=$(($length + $start_line))
    cat $FILENAME | head -n $headn | tail -n $length
  else
    # This is at the end of the file
    local len=$(cat $FILENAME | wc -l)
    cat $FILENAME | tail -n $(($len - $start_line))
  fi
}

# Creates an annotated git tag based on a changelog entry
tag() {
  local parse_cmd="parse $FILENAME $TAG" real_tag="$TAG"

  # Prepend a "v" if required
  if [ ! -z "$ADDV" ]; then
    real_tag="v$TAG"
  fi

  # Run the command and get the exit code
  local cmd="git tag $SIGN $FORCE -a -F - $real_tag"
  if [ ! -z "$DEBUG" ]; then
    debug "Tagging $real_tag with the following annotation:\n"
    debug "===[ BEGIN ]===\n$($parse_cmd)\n===[  END  ]===\n"
    debug "Running git command: $cmd"
  fi

  $parse_cmd | $cmd || {
    die "[FAILURE] Failed tagging $tag: Error code $success"
  }

  echo "[SUCCESS] Tagged $real_tag"
}

list() {
  local pattern="^($HEADING_START) $HEADING_END"
  grep -E -e "$pattern" $FILENAME | sed -E 's/\ .+$//'
}

latest() {
  list | head -n1
}

main "$@"
