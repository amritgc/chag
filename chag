#!/usr/bin/env bash
#
# Create annotated git tags from a changelog entry.
#
# Author:  Michael Dowling <https://github.com/mtdowling>
# License: MIT <https://github.com/mtdowling/chag/blob/master/LICENSE>
# URL:     https://github.com/mtdowling/chag

chag_usage() {
  cat <<EOT
Usage: chag [OPTIONS] COMMAND [ARGS]...

Options:
  --help  Displays this message.

Commands:
  parse
  tag

EOT
}

chag_parse_usage() {
  cat <<EOT
Usage: chag parse [OPTIONS] FILENAME

Options:
  --tag      Optional tag to parse. If no value is provided, then
             the latest tag will be parsed.
  --debug    Set to 1 to output debug information while executing.
  --help     Displays this message.

Arguments:
  FILENAME   Path to the changelog file to parse.

Description:
  Parses a changelog entry from a changelog file. A changelog
  file consists of various release entries, each designated by a line
  that matches the following pattern: \d+\.\d+\.\d+ \(\d{4}\-\d{2}\d{2}\)
  After each release entry heading, are two lines of text that are
  disregarded, followed by n number of lines of the changelog entry
  content. An entry is parsed until the next heading or EOF.

Output:
  Outputs the tag of the corresponding entry, the date of the
  entry, and the path to a file on disk containing the contents
  of the entry, all separated by a single space.

Examples:

  ./chag /path/to/CHANGELOG.md
  Outputs: 1.0.1 2014-12-25 /tmp/1.0.1-XXXX

  ./chag --tag 1.0.1 /path/to/CHANGELOG.md
  Outputs: 1.0.1 2014-12-25 /tmp/1.0.1-XXXX

EOT
}

chag_tag_usage() {
  cat <<EOT
Usage: chag tag [OPTIONS] FILENAME

Options:
  --tag      Optional tag to parse. If no value is provided, then
             the latest tag will be parsed. Defaults to "latest".
  --message  Optional message to prepend to the annotated tag description.
             Pass "{date}" to automatically fill in the date of the release
             as the description title.
  --sign     Make a GPG-signed tag, using the default git e-mail address's key.
  --debug    Set to 1 to output debug information while executing.
  --help     Displays this message.

Arguments:
  FILENAME   Path to the changelog to parse

Description:
  Parses a changelog entry for the given tag (or latest tag) and creates an
  annotated git tag based on the changelog entry.

Examples:
  ./chag tag /path/to/CHANGELOG.md
  ./chag tag --debug CHANGELOG.rst
  ./chag tag --tag 4.1.0 CHANGELOG.md
  ./chag tag --sign CHANGELOG.rst
  ./chag tag --message "{date}" CHANGELOG.rst
  ./chag tag --message "Release code name" CHANGELOG.rst

EOT
}

# Clear out the variables used in the script
declare COMMAND= FILENAME= TAG= MESSAGE= OUTPUT= SIGN=

# Extracts options and arguments, validates, and calls a subcommand
chag_main() {
  # Show help if no options or arguments are provided
  [ $# -eq 0 ] && set -- --help
  [ "$1" == '--help' ] && chag_usage && exit 0
  COMMAND="$1"
  shift

  # Call the appropriate command or display the command's help message
  case "$COMMAND" in
    parse)
      [ "$1" == "--help" ] && chag_parse_usage && exit 0
      parse_options $@
      chag_parse
      ;;
    tag)
      [ "$1" == "--help" ] && chag_tag_usage && exit 0
      parse_options $@
      chag_tag
      ;;
    *)
      printf "ERROR: Unknown command '$COMMAND'.\n\n"
      chag_usage && exit 1
      ;;
  esac
}

parse_options() {
  while [ $# -gt 0 ]; do
    opt="$1"
    shift
    case "$opt" in
      --tag) TAG="$1"; shift ;;
      --message) MESSAGE="$1"; shift ;;
      --debug) DEBUG=1 ;;
      --sign|-s) SIGN="--sign" ;;
      --*) die "ERROR: Unexpected option: $opt" ;;
      *) FILENAME=$opt; break ;;
    esac
  done

  # Parse the FILENAME argument
  [ "$FILENAME" == "" ] && die "$COMMAND requires a FILENAME argument";
  [ ! -f "$FILENAME" ] && die "File not found: $FILENAME"
  [ -z "$TAG" ] && TAG="latest"
}

# exits with an error message
die() {
  echo "$1" && exit 1
}

# Outputs debug information if DEBUG was passed
debug() {
  [ ! -z "$DEBUG" ] && printf "$@\n" >&2
}

# Parses a changelog and displays changelog information
chag_parse() {
  local heading='^\d+\.\d+\.\d+ \(\d{4}\-\d{2}\-\d{2}\)$'
  local pattern=$heading
  if [ "$TAG" != "latest" ]; then
    pattern="^$TAG \(\d{4}\-\d{2}\-\d{2}\)\$"
  fi

  # Find the tag pattern
  local match=$(grep -n -E "$pattern" $FILENAME | head -n1)
  # The match MUST be found
  [ "$match" == "" ] && echo "Tag $TAG not found" && exit 1

  # Parse the match: 0:0.0.0 (0000-00-00)
  local found_line=$(echo "$match" | cut -d ':' -f 1)
  local lastpart=$(echo "$match" | cut -d ':' -f 2)
  local found_tag=$(echo "$lastpart" | cut -d ' ' -f 1)
  local mdate=$(echo "$lastpart" | cut -d ' ' -f 2)
  local found_date=${mdate:1:10}
  local tmpfile=$(mktemp -t "tag-$found_tag.XXXXXXXXXX")

  # First line in the file of the changelog
  local start_line=$(($found_line + 2))
  # Find the length of the section
  local length=$(tail -n +$start_line "$FILENAME" | \
                 grep -n -E "$heading" | \
                 head -n1 | \
                 cut -d ':' -f 1)
  length=$(($length - 3))

  if [ "$length" -gt 0 ]; then
    # This is not at the end of the file
    cat $FILENAME | \
        head -n $(($length + $start_line)) | \
        tail -n $length \
        > $tmpfile
  else
    # This is at the end of the file
    local len=$(cat $FILENAME | wc -l)
    cat $FILENAME | \
        tail -n $(($len - $start_line)) \
         > $tmpfile
  fi

  echo $found_tag $found_date $tmpfile
}

# Creates an annotated git tag based on a changelog entry
chag_tag() {
  data="$(chag_parse --tag $TAG $FILENAME 2>&1)"
  [ "$?" -eq 1 ] && die $data

  # Split the result into individual pieces
  tag=$(echo $data | cut -d ' ' -f 1)
  date=$(echo $data | cut -d ' ' -f 2)
  tmp=$(echo $data | cut -d ' ' -f 3)

  debug "Parsed the $tag changelog entry from $FILENAME:"
  debug "  tag: $tag, date: $date, tmpfile: $tmp"

  # Use substitution for {date}
  [ "$MESSAGE" == '{date}' ] && MESSAGE="$date"

  # Prepend to the title if necessary
  if [ "$MESSAGE" != "" ]; then
    printf "$MESSAGE\n\n" | cat - $tmp > /tmp/out && mv /tmp/out $tmp
  fi

  # Run the command and get the exit code
  local cmd="git tag $SIGN -a -F $tmp $tag"
  debug "Running $cmd" && $cmd
  local success="$?"
  if [ $success -ne 0 ]; then
    rm $tmp || echo "Temp file not found: $tmp"
    die "[FAILURE] Failed tagging $tag: Error code $success"
  fi

  echo "[SUCCESS] Tagged the $tag release"
  debug "Tagged $tag with the following annotation:\n\n$(cat $tmp)"
  rm $tmp || echo "Temp file not found: $tmp"
}

chag_main "$@"
